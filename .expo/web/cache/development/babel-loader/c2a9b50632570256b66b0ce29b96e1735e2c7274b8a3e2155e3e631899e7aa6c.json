{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport KeyboardAvoidingView from \"react-native-web/dist/exports/KeyboardAvoidingView\";\nimport Modal from \"react-native-web/dist/exports/Modal\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport View from \"react-native-web/dist/exports/View\";\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage } from \"./utils\";\nimport styles from \"./modal.style\";\ninitializeAnimations();\nvar extractAnimationFromProps = function extractAnimationFromProps(props) {\n  return {\n    animationIn: props.animationIn,\n    animationOut: props.animationOut\n  };\n};\nexport var ReactNativeModal = function (_React$Component) {\n  _inherits(ReactNativeModal, _React$Component);\n  var _super = _createSuper(ReactNativeModal);\n  function ReactNativeModal(props) {\n    var _this;\n    _classCallCheck(this, ReactNativeModal);\n    _this = _super.call(this, props);\n    _this.state = {\n      showContent: true,\n      isVisible: false,\n      deviceWidth: Dimensions.get('screen').width,\n      deviceHeight: Dimensions.get('screen').height,\n      isSwipeable: _this.props.swipeDirection ? true : false,\n      pan: null\n    };\n    _this.isTransitioning = false;\n    _this.inSwipeClosingState = false;\n    _this.currentSwipingDirection = null;\n    _this.panResponder = null;\n    _this.buildPanResponder = function () {\n      var animEvt = null;\n      _this.panResponder = PanResponder.create({\n        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {\n          if (!_this.props.propagateSwipe) {\n            var shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;\n            if (shouldSetPanResponder && _this.props.onSwipeStart) {\n              _this.props.onSwipeStart();\n            }\n            _this.currentSwipingDirection = _this.getSwipingDirection(gestureState);\n            animEvt = _this.createAnimationEventForSwipe();\n            return shouldSetPanResponder;\n          }\n          return false;\n        },\n        onStartShouldSetPanResponder: function onStartShouldSetPanResponder(e) {\n          var hasScrollableView = e._dispatchInstances && e._dispatchInstances.some(function (instance) {\n            return /scrollview|flatlist/i.test(instance.type);\n          });\n          if (hasScrollableView && _this.props.propagateSwipe && _this.props.scrollTo && _this.props.scrollOffset > 0) {\n            return false;\n          }\n          if (_this.props.onSwipeStart) {\n            _this.props.onSwipeStart();\n          }\n          _this.currentSwipingDirection = null;\n          return true;\n        },\n        onPanResponderMove: function onPanResponderMove(evt, gestureState) {\n          if (!_this.currentSwipingDirection) {\n            if (gestureState.dx === 0 && gestureState.dy === 0) {\n              return;\n            }\n            _this.currentSwipingDirection = _this.getSwipingDirection(gestureState);\n            animEvt = _this.createAnimationEventForSwipe();\n          }\n          if (_this.isSwipeDirectionAllowed(gestureState)) {\n            var newOpacityFactor = 1 - _this.calcDistancePercentage(gestureState);\n            _this.backdropRef && _this.backdropRef.transitionTo({\n              opacity: _this.props.backdropOpacity * newOpacityFactor\n            });\n            animEvt(evt, gestureState);\n            if (_this.props.onSwipeMove) {\n              _this.props.onSwipeMove(newOpacityFactor);\n            }\n          } else {\n            if (_this.props.scrollTo) {\n              if (_this.props.scrollHorizontal) {\n                var offsetX = -gestureState.dx;\n                if (offsetX > _this.props.scrollOffsetMax) {\n                  offsetX -= (offsetX - _this.props.scrollOffsetMax) / 2;\n                }\n                _this.props.scrollTo({\n                  x: offsetX,\n                  animated: false\n                });\n              } else {\n                var offsetY = -gestureState.dy;\n                if (offsetY > _this.props.scrollOffsetMax) {\n                  offsetY -= (offsetY - _this.props.scrollOffsetMax) / 2;\n                }\n                _this.props.scrollTo({\n                  y: offsetY,\n                  animated: false\n                });\n              }\n            }\n          }\n        },\n        onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {\n          var accDistance = _this.getAccDistancePerDirection(gestureState);\n          if (accDistance > _this.props.swipeThreshold && _this.isSwipeDirectionAllowed(gestureState)) {\n            if (_this.props.onSwipeComplete) {\n              _this.inSwipeClosingState = true;\n              _this.props.onSwipeComplete({\n                swipingDirection: _this.getSwipingDirection(gestureState)\n              });\n              return;\n            }\n            if (_this.props.onSwipe) {\n              _this.inSwipeClosingState = true;\n              _this.props.onSwipe();\n              return;\n            }\n          }\n          if (_this.props.onSwipeCancel) {\n            _this.props.onSwipeCancel();\n          }\n          if (_this.backdropRef) {\n            _this.backdropRef.transitionTo({\n              opacity: _this.props.backdropOpacity\n            });\n          }\n          Animated.spring(_this.state.pan, {\n            toValue: {\n              x: 0,\n              y: 0\n            },\n            bounciness: 0,\n            useNativeDriver: false\n          }).start();\n          if (_this.props.scrollTo) {\n            if (_this.props.scrollOffset > _this.props.scrollOffsetMax) {\n              _this.props.scrollTo({\n                y: _this.props.scrollOffsetMax,\n                animated: true\n              });\n            }\n          }\n        }\n      });\n    };\n    _this.getAccDistancePerDirection = function (gestureState) {\n      switch (_this.currentSwipingDirection) {\n        case 'up':\n          return -gestureState.dy;\n        case 'down':\n          return gestureState.dy;\n        case 'right':\n          return gestureState.dx;\n        case 'left':\n          return -gestureState.dx;\n        default:\n          return 0;\n      }\n    };\n    _this.getSwipingDirection = function (gestureState) {\n      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n        return gestureState.dx > 0 ? 'right' : 'left';\n      }\n      return gestureState.dy > 0 ? 'down' : 'up';\n    };\n    _this.calcDistancePercentage = function (gestureState) {\n      switch (_this.currentSwipingDirection) {\n        case 'down':\n          return (gestureState.moveY - gestureState.y0) / ((_this.props.deviceHeight || _this.state.deviceHeight) - gestureState.y0);\n        case 'up':\n          return reversePercentage(gestureState.moveY / gestureState.y0);\n        case 'left':\n          return reversePercentage(gestureState.moveX / gestureState.x0);\n        case 'right':\n          return (gestureState.moveX - gestureState.x0) / ((_this.props.deviceWidth || _this.state.deviceWidth) - gestureState.x0);\n        default:\n          return 0;\n      }\n    };\n    _this.createAnimationEventForSwipe = function () {\n      if (_this.currentSwipingDirection === 'right' || _this.currentSwipingDirection === 'left') {\n        return Animated.event([null, {\n          dx: _this.state.pan.x\n        }], {\n          useNativeDriver: false\n        });\n      } else {\n        return Animated.event([null, {\n          dy: _this.state.pan.y\n        }], {\n          useNativeDriver: false\n        });\n      }\n    };\n    _this.isDirectionIncluded = function (direction) {\n      return Array.isArray(_this.props.swipeDirection) ? _this.props.swipeDirection.includes(direction) : _this.props.swipeDirection === direction;\n    };\n    _this.isSwipeDirectionAllowed = function (_ref) {\n      var dy = _ref.dy,\n        dx = _ref.dx;\n      var draggedDown = dy > 0;\n      var draggedUp = dy < 0;\n      var draggedLeft = dx < 0;\n      var draggedRight = dx > 0;\n      if (_this.currentSwipingDirection === 'up' && _this.isDirectionIncluded('up') && draggedUp) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'down' && _this.isDirectionIncluded('down') && draggedDown) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'right' && _this.isDirectionIncluded('right') && draggedRight) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'left' && _this.isDirectionIncluded('left') && draggedLeft) {\n        return true;\n      }\n      return false;\n    };\n    _this.handleDimensionsUpdate = function () {\n      if (!_this.props.deviceHeight && !_this.props.deviceWidth) {\n        var deviceWidth = Dimensions.get('screen').width;\n        var deviceHeight = Dimensions.get('screen').height;\n        if (deviceWidth !== _this.state.deviceWidth || deviceHeight !== _this.state.deviceHeight) {\n          _this.setState({\n            deviceWidth: deviceWidth,\n            deviceHeight: deviceHeight\n          });\n        }\n      }\n    };\n    _this.open = function () {\n      if (_this.isTransitioning) {\n        return;\n      }\n      _this.isTransitioning = true;\n      if (_this.backdropRef) {\n        _this.backdropRef.transitionTo({\n          opacity: _this.props.backdropOpacity\n        }, _this.props.backdropTransitionInTiming);\n      }\n      if (_this.state.isSwipeable) {\n        _this.state.pan.setValue({\n          x: 0,\n          y: 0\n        });\n      }\n      if (_this.contentRef) {\n        _this.props.onModalWillShow && _this.props.onModalWillShow();\n        _this.contentRef.animate(_this.animationIn, _this.props.animationInTiming).then(function () {\n          _this.isTransitioning = false;\n          if (!_this.props.isVisible) {\n            _this.close();\n          } else {\n            _this.props.onModalShow();\n          }\n        });\n      }\n    };\n    _this.close = function () {\n      if (_this.isTransitioning) {\n        return;\n      }\n      _this.isTransitioning = true;\n      if (_this.backdropRef) {\n        _this.backdropRef.transitionTo({\n          opacity: 0\n        }, _this.props.backdropTransitionOutTiming);\n      }\n      var animationOut = _this.animationOut;\n      if (_this.inSwipeClosingState) {\n        _this.inSwipeClosingState = false;\n        if (_this.currentSwipingDirection === 'up') {\n          animationOut = 'slideOutUp';\n        } else if (_this.currentSwipingDirection === 'down') {\n          animationOut = 'slideOutDown';\n        } else if (_this.currentSwipingDirection === 'right') {\n          animationOut = 'slideOutRight';\n        } else if (_this.currentSwipingDirection === 'left') {\n          animationOut = 'slideOutLeft';\n        }\n      }\n      if (_this.contentRef) {\n        _this.props.onModalWillHide && _this.props.onModalWillHide();\n        _this.contentRef.animate(animationOut, _this.props.animationOutTiming).then(function () {\n          _this.isTransitioning = false;\n          if (_this.props.isVisible) {\n            _this.open();\n          } else {\n            _this.setState({\n              showContent: false\n            }, function () {\n              _this.setState({\n                isVisible: false\n              }, function () {\n                _this.props.onModalHide();\n              });\n            });\n          }\n        });\n      }\n    };\n    var _buildAnimations = buildAnimations(extractAnimationFromProps(props)),\n      animationIn = _buildAnimations.animationIn,\n      animationOut = _buildAnimations.animationOut;\n    _this.animationIn = animationIn;\n    _this.animationOut = animationOut;\n    if (_this.state.isSwipeable) {\n      _this.state = _objectSpread(_objectSpread({}, _this.state), {}, {\n        pan: new Animated.ValueXY()\n      });\n      _this.buildPanResponder();\n    }\n    if (props.isVisible) {\n      _this.state = _objectSpread(_objectSpread({}, _this.state), {}, {\n        isVisible: true,\n        showContent: true\n      });\n    }\n    return _this;\n  }\n  _createClass(ReactNativeModal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.onSwipe) {\n        console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n      }\n      DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n      if (this.state.isVisible) {\n        this.open();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.animationIn !== prevProps.animationIn || this.props.animationOut !== prevProps.animationOut) {\n        var _buildAnimations2 = buildAnimations(extractAnimationFromProps(this.props)),\n          animationIn = _buildAnimations2.animationIn,\n          animationOut = _buildAnimations2.animationOut;\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n      }\n      if (this.props.backdropOpacity !== prevProps.backdropOpacity && this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: this.props.backdropOpacity\n        }, this.props.backdropTransitionInTiming);\n      }\n      if (this.props.isVisible && !prevProps.isVisible) {\n        this.open();\n      } else if (!this.props.isVisible && prevProps.isVisible) {\n        this.close();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props = this.props,\n        animationIn = _this$props.animationIn,\n        animationInTiming = _this$props.animationInTiming,\n        animationOut = _this$props.animationOut,\n        animationOutTiming = _this$props.animationOutTiming,\n        avoidKeyboard = _this$props.avoidKeyboard,\n        coverScreen = _this$props.coverScreen,\n        hasBackdrop = _this$props.hasBackdrop,\n        backdropColor = _this$props.backdropColor,\n        backdropOpacity = _this$props.backdropOpacity,\n        backdropTransitionInTiming = _this$props.backdropTransitionInTiming,\n        backdropTransitionOutTiming = _this$props.backdropTransitionOutTiming,\n        customBackdrop = _this$props.customBackdrop,\n        children = _this$props.children,\n        deviceHeightProp = _this$props.deviceHeight,\n        deviceWidthProp = _this$props.deviceWidth,\n        isVisible = _this$props.isVisible,\n        onModalShow = _this$props.onModalShow,\n        onBackdropPress = _this$props.onBackdropPress,\n        onBackButtonPress = _this$props.onBackButtonPress,\n        useNativeDriver = _this$props.useNativeDriver,\n        propagateSwipe = _this$props.propagateSwipe,\n        style = _this$props.style,\n        otherProps = _objectWithoutProperties(_this$props, [\"animationIn\", \"animationInTiming\", \"animationOut\", \"animationOutTiming\", \"avoidKeyboard\", \"coverScreen\", \"hasBackdrop\", \"backdropColor\", \"backdropOpacity\", \"backdropTransitionInTiming\", \"backdropTransitionOutTiming\", \"customBackdrop\", \"children\", \"deviceHeight\", \"deviceWidth\", \"isVisible\", \"onModalShow\", \"onBackdropPress\", \"onBackButtonPress\", \"useNativeDriver\", \"propagateSwipe\", \"style\"]);\n      var deviceWidth = deviceWidthProp || this.state.deviceWidth;\n      var deviceHeight = deviceHeightProp || this.state.deviceHeight;\n      var computedStyle = [{\n        margin: deviceWidth * 0.05,\n        transform: [{\n          translateY: 0\n        }]\n      }, styles.content, style];\n      var panHandlers = {};\n      var panPosition = {};\n      if (this.state.isSwipeable) {\n        panHandlers = _objectSpread({}, this.panResponder.panHandlers);\n        if (useNativeDriver) {\n          panPosition = {\n            transform: this.state.pan.getTranslateTransform()\n          };\n        } else {\n          panPosition = this.state.pan.getLayout();\n        }\n      }\n      var _children = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? React.createElement(animatable.View, null) : children;\n      var containerView = React.createElement(animatable.View, _extends({}, panHandlers, {\n        ref: function ref(_ref2) {\n          return _this2.contentRef = _ref2;\n        },\n        style: [panPosition, computedStyle],\n        pointerEvents: \"box-none\",\n        useNativeDriver: useNativeDriver\n      }, otherProps), _children);\n      var hasCustomBackdrop = React.isValidElement(customBackdrop);\n      var backdropComputedStyle = [{\n        width: deviceWidth,\n        height: deviceHeight,\n        backgroundColor: this.state.showContent && !hasCustomBackdrop ? backdropColor : 'transparent'\n      }];\n      var backdropContent = React.createElement(animatable.View, {\n        ref: function ref(_ref3) {\n          return _this2.backdropRef = _ref3;\n        },\n        useNativeDriver: useNativeDriver,\n        style: [styles.backdrop, backdropComputedStyle]\n      }, hasCustomBackdrop && customBackdrop);\n      var backdrop = null;\n      if (hasCustomBackdrop) {\n        backdrop = backdropContent;\n      } else {\n        backdrop = React.createElement(TouchableWithoutFeedback, {\n          onPress: onBackdropPress\n        }, backdropContent);\n      }\n      if (!coverScreen && this.state.isVisible) {\n        return React.createElement(View, {\n          pointerEvents: \"box-none\",\n          style: [styles.backdrop, styles.containerBox]\n        }, hasBackdrop && backdrop, containerView);\n      }\n      return React.createElement(Modal, _extends({\n        transparent: true,\n        animationType: 'none',\n        visible: this.state.isVisible,\n        onRequestClose: onBackButtonPress\n      }, otherProps), hasBackdrop && backdrop, avoidKeyboard && React.createElement(KeyboardAvoidingView, {\n        behavior: Platform.OS === 'ios' ? 'padding' : undefined,\n        pointerEvents: \"box-none\",\n        style: computedStyle.concat([{\n          margin: 0\n        }])\n      }, containerView), !avoidKeyboard && containerView);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, state) {\n      if (!state.isVisible && nextProps.isVisible) {\n        return {\n          isVisible: true,\n          showContent: true\n        };\n      }\n      return null;\n    }\n  }]);\n  return ReactNativeModal;\n}(React.Component);\nReactNativeModal.propTypes = {\n  animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationInTiming: PropTypes.number,\n  animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationOutTiming: PropTypes.number,\n  avoidKeyboard: PropTypes.bool,\n  coverScreen: PropTypes.bool,\n  hasBackdrop: PropTypes.bool,\n  backdropColor: PropTypes.string,\n  backdropOpacity: PropTypes.number,\n  backdropTransitionInTiming: PropTypes.number,\n  backdropTransitionOutTiming: PropTypes.number,\n  customBackdrop: PropTypes.node,\n  children: PropTypes.node.isRequired,\n  deviceHeight: PropTypes.number,\n  deviceWidth: PropTypes.number,\n  isVisible: PropTypes.bool.isRequired,\n  hideModalContentWhileAnimating: PropTypes.bool,\n  propagateSwipe: PropTypes.bool,\n  onModalShow: PropTypes.func,\n  onModalWillShow: PropTypes.func,\n  onModalHide: PropTypes.func,\n  onModalWillHide: PropTypes.func,\n  onBackButtonPress: PropTypes.func,\n  onBackdropPress: PropTypes.func,\n  onSwipeStart: PropTypes.func,\n  onSwipeMove: PropTypes.func,\n  onSwipeComplete: PropTypes.func,\n  onSwipeCancel: PropTypes.func,\n  swipeThreshold: PropTypes.number,\n  swipeDirection: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])), PropTypes.oneOf(['up', 'down', 'left', 'right'])]),\n  useNativeDriver: PropTypes.bool,\n  style: PropTypes.any,\n  scrollTo: PropTypes.func,\n  scrollOffset: PropTypes.number,\n  scrollOffsetMax: PropTypes.number,\n  scrollHorizontal: PropTypes.bool,\n  supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']))\n};\nReactNativeModal.defaultProps = {\n  animationIn: 'slideInUp',\n  animationInTiming: 300,\n  animationOut: 'slideOutDown',\n  animationOutTiming: 300,\n  avoidKeyboard: false,\n  coverScreen: true,\n  hasBackdrop: true,\n  backdropColor: 'black',\n  backdropOpacity: 0.7,\n  backdropTransitionInTiming: 300,\n  backdropTransitionOutTiming: 300,\n  customBackdrop: null,\n  useNativeDriver: false,\n  deviceHeight: null,\n  deviceWidth: null,\n  hideModalContentWhileAnimating: false,\n  propagateSwipe: false,\n  isVisible: false,\n  onModalShow: function onModalShow() {\n    return null;\n  },\n  onModalWillShow: function onModalWillShow() {\n    return null;\n  },\n  onModalHide: function onModalHide() {\n    return null;\n  },\n  onModalWillHide: function onModalWillHide() {\n    return null;\n  },\n  onBackdropPress: function onBackdropPress() {\n    return null;\n  },\n  onBackButtonPress: function onBackButtonPress() {\n    return null;\n  },\n  swipeThreshold: 100,\n  scrollTo: null,\n  scrollOffset: 0,\n  scrollOffsetMax: 0,\n  scrollHorizontal: false,\n  supportedOrientations: ['portrait', 'landscape']\n};\nexport default ReactNativeModal;","map":{"version":3,"names":["React","Animated","DeviceEventEmitter","Dimensions","KeyboardAvoidingView","Modal","PanResponder","Platform","TouchableWithoutFeedback","View","PropTypes","animatable","initializeAnimations","buildAnimations","reversePercentage","styles","extractAnimationFromProps","props","animationIn","animationOut","ReactNativeModal","_React$Component","_inherits","_super","_createSuper","_this","_classCallCheck","call","state","showContent","isVisible","deviceWidth","get","width","deviceHeight","height","isSwipeable","swipeDirection","pan","isTransitioning","inSwipeClosingState","currentSwipingDirection","panResponder","buildPanResponder","animEvt","create","onMoveShouldSetPanResponder","evt","gestureState","propagateSwipe","shouldSetPanResponder","Math","abs","dx","dy","onSwipeStart","getSwipingDirection","createAnimationEventForSwipe","onStartShouldSetPanResponder","e","hasScrollableView","_dispatchInstances","some","instance","test","type","scrollTo","scrollOffset","onPanResponderMove","isSwipeDirectionAllowed","newOpacityFactor","calcDistancePercentage","backdropRef","transitionTo","opacity","backdropOpacity","onSwipeMove","scrollHorizontal","offsetX","scrollOffsetMax","x","animated","offsetY","y","onPanResponderRelease","accDistance","getAccDistancePerDirection","swipeThreshold","onSwipeComplete","swipingDirection","onSwipe","onSwipeCancel","spring","toValue","bounciness","useNativeDriver","start","moveY","y0","moveX","x0","event","isDirectionIncluded","direction","Array","isArray","includes","_ref","draggedDown","draggedUp","draggedLeft","draggedRight","handleDimensionsUpdate","setState","open","backdropTransitionInTiming","setValue","contentRef","onModalWillShow","animate","animationInTiming","then","close","onModalShow","backdropTransitionOutTiming","onModalWillHide","animationOutTiming","onModalHide","_buildAnimations","_objectSpread","ValueXY","_createClass","key","value","componentDidMount","console","warn","addListener","componentWillUnmount","removeListener","componentDidUpdate","prevProps","_buildAnimations2","render","_this2","_this$props","avoidKeyboard","coverScreen","hasBackdrop","backdropColor","customBackdrop","children","deviceHeightProp","deviceWidthProp","onBackdropPress","onBackButtonPress","style","otherProps","_objectWithoutProperties","computedStyle","margin","transform","translateY","content","panHandlers","panPosition","getTranslateTransform","getLayout","_children","hideModalContentWhileAnimating","createElement","containerView","_extends","ref","pointerEvents","hasCustomBackdrop","isValidElement","backdropComputedStyle","backgroundColor","backdropContent","backdrop","onPress","containerBox","transparent","animationType","visible","onRequestClose","behavior","OS","undefined","concat","getDerivedStateFromProps","nextProps","Component","propTypes","oneOfType","string","object","number","bool","node","isRequired","func","arrayOf","oneOf","any","supportedOrientations","defaultProps"],"sources":["C:/Users/hibab/Downloads/aina19/pingaina/node_modules/react-native-modal/dist/modal.js"],"sourcesContent":["import * as React from 'react';\nimport { Animated, DeviceEventEmitter, Dimensions, KeyboardAvoidingView, Modal, PanResponder, Platform, TouchableWithoutFeedback, View, } from 'react-native';\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage, } from './utils';\nimport styles from './modal.style';\n// Override default react-native-animatable animations\ninitializeAnimations();\nconst extractAnimationFromProps = (props) => ({\n    animationIn: props.animationIn,\n    animationOut: props.animationOut,\n});\nexport class ReactNativeModal extends React.Component {\n    constructor(props) {\n        super(props);\n        // We use an internal state for keeping track of the modal visibility: this allows us to keep\n        // the modal visible during the exit animation, even if the user has already change the\n        // isVisible prop to false.\n        // We store in the state the device width and height so that we can update the modal on\n        // device rotation.\n        this.state = {\n            showContent: true,\n            isVisible: false,\n            deviceWidth: Dimensions.get('screen').width,\n            deviceHeight: Dimensions.get('screen').height,\n            isSwipeable: this.props.swipeDirection ? true : false,\n            pan: null,\n        };\n        this.isTransitioning = false;\n        this.inSwipeClosingState = false;\n        this.currentSwipingDirection = null;\n        this.panResponder = null;\n        this.buildPanResponder = () => {\n            let animEvt = null;\n            this.panResponder = PanResponder.create({\n                onMoveShouldSetPanResponder: (evt, gestureState) => {\n                    // Use propagateSwipe to allow inner content to scroll. See PR:\n                    // https://github.com/react-native-community/react-native-modal/pull/246\n                    if (!this.props.propagateSwipe) {\n                        // The number \"4\" is just a good tradeoff to make the panResponder\n                        // work correctly even when the modal has touchable buttons.\n                        // For reference:\n                        // https://github.com/react-native-community/react-native-modal/pull/197\n                        const shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;\n                        if (shouldSetPanResponder && this.props.onSwipeStart) {\n                            this.props.onSwipeStart();\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                        return shouldSetPanResponder;\n                    }\n                    return false;\n                },\n                onStartShouldSetPanResponder: (e) => {\n                    const hasScrollableView = e._dispatchInstances &&\n                        e._dispatchInstances.some((instance) => /scrollview|flatlist/i.test(instance.type));\n                    if (hasScrollableView &&\n                        this.props.propagateSwipe &&\n                        this.props.scrollTo &&\n                        this.props.scrollOffset > 0) {\n                        return false; // user needs to be able to scroll content back up\n                    }\n                    if (this.props.onSwipeStart) {\n                        this.props.onSwipeStart();\n                    }\n                    // Cleared so that onPanResponderMove can wait to have some delta\n                    // to work with\n                    this.currentSwipingDirection = null;\n                    return true;\n                },\n                onPanResponderMove: (evt, gestureState) => {\n                    // Using onStartShouldSetPanResponder we don't have any delta so we don't know\n                    // The direction to which the user is swiping until some move have been done\n                    if (!this.currentSwipingDirection) {\n                        if (gestureState.dx === 0 && gestureState.dy === 0) {\n                            return;\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                    }\n                    if (this.isSwipeDirectionAllowed(gestureState)) {\n                        // Dim the background while swiping the modal\n                        const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n                        this.backdropRef &&\n                            this.backdropRef.transitionTo({\n                                opacity: this.props.backdropOpacity * newOpacityFactor,\n                            });\n                        animEvt(evt, gestureState);\n                        if (this.props.onSwipeMove) {\n                            this.props.onSwipeMove(newOpacityFactor);\n                        }\n                    }\n                    else {\n                        if (this.props.scrollTo) {\n                            if (this.props.scrollHorizontal) {\n                                let offsetX = -gestureState.dx;\n                                if (offsetX > this.props.scrollOffsetMax) {\n                                    offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ x: offsetX, animated: false });\n                            }\n                            else {\n                                let offsetY = -gestureState.dy;\n                                if (offsetY > this.props.scrollOffsetMax) {\n                                    offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ y: offsetY, animated: false });\n                            }\n                        }\n                    }\n                },\n                onPanResponderRelease: (evt, gestureState) => {\n                    // Call the onSwipe prop if the threshold has been exceeded on the right direction\n                    const accDistance = this.getAccDistancePerDirection(gestureState);\n                    if (accDistance > this.props.swipeThreshold &&\n                        this.isSwipeDirectionAllowed(gestureState)) {\n                        if (this.props.onSwipeComplete) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipeComplete({\n                                swipingDirection: this.getSwipingDirection(gestureState),\n                            });\n                            return;\n                        }\n                        // Deprecated. Remove later.\n                        if (this.props.onSwipe) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipe();\n                            return;\n                        }\n                    }\n                    //Reset backdrop opacity and modal position\n                    if (this.props.onSwipeCancel) {\n                        this.props.onSwipeCancel();\n                    }\n                    if (this.backdropRef) {\n                        this.backdropRef.transitionTo({\n                            opacity: this.props.backdropOpacity,\n                        });\n                    }\n                    Animated.spring(this.state.pan, {\n                        toValue: { x: 0, y: 0 },\n                        bounciness: 0,\n                        useNativeDriver: false,\n                    }).start();\n                    if (this.props.scrollTo) {\n                        if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n                            this.props.scrollTo({\n                                y: this.props.scrollOffsetMax,\n                                animated: true,\n                            });\n                        }\n                    }\n                },\n            });\n        };\n        this.getAccDistancePerDirection = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'up':\n                    return -gestureState.dy;\n                case 'down':\n                    return gestureState.dy;\n                case 'right':\n                    return gestureState.dx;\n                case 'left':\n                    return -gestureState.dx;\n                default:\n                    return 0;\n            }\n        };\n        this.getSwipingDirection = (gestureState) => {\n            if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n                return gestureState.dx > 0 ? 'right' : 'left';\n            }\n            return gestureState.dy > 0 ? 'down' : 'up';\n        };\n        this.calcDistancePercentage = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'down':\n                    return ((gestureState.moveY - gestureState.y0) /\n                        ((this.props.deviceHeight || this.state.deviceHeight) -\n                            gestureState.y0));\n                case 'up':\n                    return reversePercentage(gestureState.moveY / gestureState.y0);\n                case 'left':\n                    return reversePercentage(gestureState.moveX / gestureState.x0);\n                case 'right':\n                    return ((gestureState.moveX - gestureState.x0) /\n                        ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0));\n                default:\n                    return 0;\n            }\n        };\n        this.createAnimationEventForSwipe = () => {\n            if (this.currentSwipingDirection === 'right' ||\n                this.currentSwipingDirection === 'left') {\n                return Animated.event([null, { dx: this.state.pan.x }], {\n                    useNativeDriver: false,\n                });\n            }\n            else {\n                return Animated.event([null, { dy: this.state.pan.y }], {\n                    useNativeDriver: false,\n                });\n            }\n        };\n        this.isDirectionIncluded = (direction) => {\n            return Array.isArray(this.props.swipeDirection)\n                ? this.props.swipeDirection.includes(direction)\n                : this.props.swipeDirection === direction;\n        };\n        this.isSwipeDirectionAllowed = ({ dy, dx }) => {\n            const draggedDown = dy > 0;\n            const draggedUp = dy < 0;\n            const draggedLeft = dx < 0;\n            const draggedRight = dx > 0;\n            if (this.currentSwipingDirection === 'up' &&\n                this.isDirectionIncluded('up') &&\n                draggedUp) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'down' &&\n                this.isDirectionIncluded('down') &&\n                draggedDown) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'right' &&\n                this.isDirectionIncluded('right') &&\n                draggedRight) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'left' &&\n                this.isDirectionIncluded('left') &&\n                draggedLeft) {\n                return true;\n            }\n            return false;\n        };\n        this.handleDimensionsUpdate = () => {\n            if (!this.props.deviceHeight && !this.props.deviceWidth) {\n                // Here we update the device dimensions in the state if the layout changed\n                // (triggering a render)\n                const deviceWidth = Dimensions.get('screen').width;\n                const deviceHeight = Dimensions.get('screen').height;\n                if (deviceWidth !== this.state.deviceWidth ||\n                    deviceHeight !== this.state.deviceHeight) {\n                    this.setState({ deviceWidth, deviceHeight });\n                }\n            }\n        };\n        this.open = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n            }\n            // This is for resetting the pan position,otherwise the modal gets stuck\n            // at the last released position when you try to open it.\n            // TODO: Could certainly be improved - no idea for the moment.\n            if (this.state.isSwipeable) {\n                this.state.pan.setValue({ x: 0, y: 0 });\n            }\n            if (this.contentRef) {\n                this.props.onModalWillShow && this.props.onModalWillShow();\n                this.contentRef\n                    .animate(this.animationIn, this.props.animationInTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    if (!this.props.isVisible) {\n                        this.close();\n                    }\n                    else {\n                        this.props.onModalShow();\n                    }\n                });\n            }\n        };\n        this.close = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: 0 }, this.props.backdropTransitionOutTiming);\n            }\n            let animationOut = this.animationOut;\n            if (this.inSwipeClosingState) {\n                this.inSwipeClosingState = false;\n                if (this.currentSwipingDirection === 'up') {\n                    animationOut = 'slideOutUp';\n                }\n                else if (this.currentSwipingDirection === 'down') {\n                    animationOut = 'slideOutDown';\n                }\n                else if (this.currentSwipingDirection === 'right') {\n                    animationOut = 'slideOutRight';\n                }\n                else if (this.currentSwipingDirection === 'left') {\n                    animationOut = 'slideOutLeft';\n                }\n            }\n            if (this.contentRef) {\n                this.props.onModalWillHide && this.props.onModalWillHide();\n                this.contentRef\n                    .animate(animationOut, this.props.animationOutTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    if (this.props.isVisible) {\n                        this.open();\n                    }\n                    else {\n                        this.setState({\n                            showContent: false,\n                        }, () => {\n                            this.setState({\n                                isVisible: false,\n                            }, () => {\n                                this.props.onModalHide();\n                            });\n                        });\n                    }\n                });\n            }\n        };\n        const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(props));\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n        if (this.state.isSwipeable) {\n            this.state = {\n                ...this.state,\n                pan: new Animated.ValueXY(),\n            };\n            this.buildPanResponder();\n        }\n        if (props.isVisible) {\n            this.state = {\n                ...this.state,\n                isVisible: true,\n                showContent: true,\n            };\n        }\n    }\n    static getDerivedStateFromProps(nextProps, state) {\n        if (!state.isVisible && nextProps.isVisible) {\n            return { isVisible: true, showContent: true };\n        }\n        return null;\n    }\n    componentDidMount() {\n        // Show deprecation message\n        if (this.props.onSwipe) {\n            console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n        }\n        DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n        if (this.state.isVisible) {\n            this.open();\n        }\n    }\n    componentWillUnmount() {\n        DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n    componentDidUpdate(prevProps) {\n        // If the animations have been changed then rebuild them to make sure we're\n        // using the most up-to-date ones\n        if (this.props.animationIn !== prevProps.animationIn ||\n            this.props.animationOut !== prevProps.animationOut) {\n            const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(this.props));\n            this.animationIn = animationIn;\n            this.animationOut = animationOut;\n        }\n        // If backdrop opacity has been changed then make sure to update it\n        if (this.props.backdropOpacity !== prevProps.backdropOpacity &&\n            this.backdropRef) {\n            this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n        }\n        // On modal open request, we slide the view up and fade in the backdrop\n        if (this.props.isVisible && !prevProps.isVisible) {\n            this.open();\n        }\n        else if (!this.props.isVisible && prevProps.isVisible) {\n            // On modal close request, we slide the view down and fade out the backdrop\n            this.close();\n        }\n    }\n    render() {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        const { animationIn, animationInTiming, animationOut, animationOutTiming, avoidKeyboard, coverScreen, hasBackdrop, backdropColor, backdropOpacity, backdropTransitionInTiming, backdropTransitionOutTiming, customBackdrop, children, deviceHeight: deviceHeightProp, deviceWidth: deviceWidthProp, isVisible, onModalShow, onBackdropPress, onBackButtonPress, useNativeDriver, propagateSwipe, style, ...otherProps } = this.props;\n        const deviceWidth = deviceWidthProp || this.state.deviceWidth;\n        const deviceHeight = deviceHeightProp || this.state.deviceHeight;\n        const computedStyle = [\n            { margin: deviceWidth * 0.05, transform: [{ translateY: 0 }] },\n            styles.content,\n            style,\n        ];\n        let panHandlers = {};\n        let panPosition = {};\n        if (this.state.isSwipeable) {\n            panHandlers = { ...this.panResponder.panHandlers };\n            if (useNativeDriver) {\n                panPosition = {\n                    transform: this.state.pan.getTranslateTransform(),\n                };\n            }\n            else {\n                panPosition = this.state.pan.getLayout();\n            }\n        }\n        const _children = this.props.hideModalContentWhileAnimating &&\n            this.props.useNativeDriver &&\n            !this.state.showContent ? (React.createElement(animatable.View, null)) : (children);\n        const containerView = (React.createElement(animatable.View, Object.assign({}, panHandlers, { ref: ref => (this.contentRef = ref), style: [panPosition, computedStyle], pointerEvents: \"box-none\", useNativeDriver: useNativeDriver }, otherProps), _children));\n        const hasCustomBackdrop = React.isValidElement(customBackdrop);\n        const backdropComputedStyle = [\n            {\n                width: deviceWidth,\n                height: deviceHeight,\n                backgroundColor: this.state.showContent && !hasCustomBackdrop\n                    ? backdropColor\n                    : 'transparent',\n            },\n        ];\n        const backdropContent = (React.createElement(animatable.View, { ref: ref => (this.backdropRef = ref), useNativeDriver: useNativeDriver, style: [styles.backdrop, backdropComputedStyle] }, hasCustomBackdrop && customBackdrop));\n        let backdrop = null;\n        if (hasCustomBackdrop) {\n            backdrop = backdropContent;\n        }\n        else {\n            // If there's no custom backdrop, handle presses with\n            // TouchableWithoutFeedback\n            backdrop = (React.createElement(TouchableWithoutFeedback, { onPress: onBackdropPress }, backdropContent));\n        }\n        if (!coverScreen && this.state.isVisible) {\n            return (React.createElement(View, { pointerEvents: \"box-none\", style: [styles.backdrop, styles.containerBox] },\n                hasBackdrop && backdrop,\n                containerView));\n        }\n        return (React.createElement(Modal, Object.assign({ transparent: true, animationType: 'none', visible: this.state.isVisible, onRequestClose: onBackButtonPress }, otherProps),\n            hasBackdrop && backdrop,\n            avoidKeyboard && (React.createElement(KeyboardAvoidingView, { behavior: Platform.OS === 'ios' ? 'padding' : undefined, pointerEvents: \"box-none\", style: computedStyle.concat([{ margin: 0 }]) }, containerView)),\n            !avoidKeyboard && containerView));\n    }\n}\nReactNativeModal.propTypes = {\n    animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationInTiming: PropTypes.number,\n    animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationOutTiming: PropTypes.number,\n    avoidKeyboard: PropTypes.bool,\n    coverScreen: PropTypes.bool,\n    hasBackdrop: PropTypes.bool,\n    backdropColor: PropTypes.string,\n    backdropOpacity: PropTypes.number,\n    backdropTransitionInTiming: PropTypes.number,\n    backdropTransitionOutTiming: PropTypes.number,\n    customBackdrop: PropTypes.node,\n    children: PropTypes.node.isRequired,\n    deviceHeight: PropTypes.number,\n    deviceWidth: PropTypes.number,\n    isVisible: PropTypes.bool.isRequired,\n    hideModalContentWhileAnimating: PropTypes.bool,\n    propagateSwipe: PropTypes.bool,\n    onModalShow: PropTypes.func,\n    onModalWillShow: PropTypes.func,\n    onModalHide: PropTypes.func,\n    onModalWillHide: PropTypes.func,\n    onBackButtonPress: PropTypes.func,\n    onBackdropPress: PropTypes.func,\n    onSwipeStart: PropTypes.func,\n    onSwipeMove: PropTypes.func,\n    onSwipeComplete: PropTypes.func,\n    onSwipeCancel: PropTypes.func,\n    swipeThreshold: PropTypes.number,\n    swipeDirection: PropTypes.oneOfType([\n        PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])),\n        PropTypes.oneOf(['up', 'down', 'left', 'right']),\n    ]),\n    useNativeDriver: PropTypes.bool,\n    style: PropTypes.any,\n    scrollTo: PropTypes.func,\n    scrollOffset: PropTypes.number,\n    scrollOffsetMax: PropTypes.number,\n    scrollHorizontal: PropTypes.bool,\n    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf([\n        'portrait',\n        'portrait-upside-down',\n        'landscape',\n        'landscape-left',\n        'landscape-right',\n    ])),\n};\nReactNativeModal.defaultProps = {\n    animationIn: 'slideInUp',\n    animationInTiming: 300,\n    animationOut: 'slideOutDown',\n    animationOutTiming: 300,\n    avoidKeyboard: false,\n    coverScreen: true,\n    hasBackdrop: true,\n    backdropColor: 'black',\n    backdropOpacity: 0.7,\n    backdropTransitionInTiming: 300,\n    backdropTransitionOutTiming: 300,\n    customBackdrop: null,\n    useNativeDriver: false,\n    deviceHeight: null,\n    deviceWidth: null,\n    hideModalContentWhileAnimating: false,\n    propagateSwipe: false,\n    isVisible: false,\n    onModalShow: () => null,\n    onModalWillShow: () => null,\n    onModalHide: () => null,\n    onModalWillHide: () => null,\n    onBackdropPress: () => null,\n    onBackButtonPress: () => null,\n    swipeThreshold: 100,\n    scrollTo: null,\n    scrollOffset: 0,\n    scrollOffsetMax: 0,\n    scrollHorizontal: false,\n    supportedOrientations: ['portrait', 'landscape'],\n};\nexport default ReactNativeModal;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}