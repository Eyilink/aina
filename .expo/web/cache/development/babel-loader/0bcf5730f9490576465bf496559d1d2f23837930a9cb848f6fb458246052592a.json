{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport queryString from 'query-string';\nexport default function getPathFromState(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n  var path = '/';\n  var current = state;\n  while (current) {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var currentOptions = options;\n    var pattern = route.name;\n    var nestedRouteNames = '';\n    while (route.name in currentOptions) {\n      if (typeof currentOptions[route.name] === 'string') {\n        pattern = currentOptions[route.name];\n        break;\n      } else if (typeof currentOptions[route.name] === 'object') {\n        if (!currentOptions[route.name].screens) {\n          pattern = currentOptions[route.name].path;\n          nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n          break;\n        } else {\n          if (route.state === undefined) {\n            pattern = currentOptions[route.name].path;\n            nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n            break;\n          } else {\n            index = typeof route.state.index === 'number' ? route.state.index : 0;\n            var nextRoute = route.state.routes[index];\n            var deeperConfig = currentOptions[route.name].screens;\n            if (nextRoute.name in deeperConfig) {\n              nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n              route = nextRoute;\n              currentOptions = deeperConfig;\n            } else {\n              pattern = currentOptions[route.name].path;\n              nestedRouteNames = \"\".concat(nestedRouteNames, \"/\").concat(route.name);\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.substring(1);\n    }\n    if (pattern !== '') {\n      (function () {\n        var config = currentOptions[route.name] !== undefined ? currentOptions[route.name].stringify : undefined;\n        var params = route.params ? Object.entries(route.params).reduce(function (acc, _ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n          acc[key] = (config === null || config === void 0 ? void 0 : config[key]) ? config[key](value) : String(value);\n          return acc;\n        }, {}) : undefined;\n        if (currentOptions[route.name] !== undefined) {\n          path += pattern.split('/').map(function (p) {\n            var name = p.replace(/^:/, '');\n            if (params && name in params && p.startsWith(':')) {\n              var value = params[name];\n              delete params[name];\n              return encodeURIComponent(value);\n            }\n            return encodeURIComponent(p);\n          }).join('/');\n        } else {\n          path += encodeURIComponent(route.name);\n        }\n        if (route.state) {\n          path += '/';\n        } else if (params) {\n          for (var param in params) {\n            if (params[param] === 'undefined') {\n              delete params[param];\n            }\n          }\n          var query = queryString.stringify(params);\n          if (query) {\n            path += \"?\".concat(query);\n          }\n        }\n      })();\n    }\n    current = route.state;\n  }\n  path = path !== '/' && path.slice(path.length - 1) === '/' ? path.slice(0, -1) : path;\n  return path;\n}","map":{"version":3,"names":["queryString","getPathFromState","state","options","arguments","length","undefined","Error","path","current","index","route","routes","currentOptions","pattern","name","nestedRouteNames","screens","concat","nextRoute","deeperConfig","substring","config","stringify","params","Object","entries","reduce","acc","_ref","_ref2","_slicedToArray","key","value","String","split","map","p","replace","startsWith","encodeURIComponent","join","param","query","slice"],"sources":["C:\\Users\\hibab\\Downloads\\aina19\\pingaina\\node_modules\\@react-navigation\\core\\lib\\module\\getPathFromState.tsx"],"sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        stringify?: StringifyConfig;\n        screens?: Options;\n      };\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: Options = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n  let path = '/';\n\n  let current: State | undefined = state;\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n    let currentOptions = options;\n    let pattern = route.name;\n    // we keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = '';\n\n    while (route.name in currentOptions) {\n      if (typeof currentOptions[route.name] === 'string') {\n        pattern = currentOptions[route.name] as string;\n        break;\n      } else if (typeof currentOptions[route.name] === 'object') {\n        // if there is no `screens` property, we return pattern\n        if (\n          !(currentOptions[route.name] as {\n            screens: Options;\n          }).screens\n        ) {\n          pattern = (currentOptions[route.name] as { path: string }).path;\n          nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n          break;\n        } else {\n          // if it is the end of state, we return pattern\n          if (route.state === undefined) {\n            pattern = (currentOptions[route.name] as { path: string }).path;\n            nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n            break;\n          } else {\n            index =\n              typeof route.state.index === 'number' ? route.state.index : 0;\n            const nextRoute = route.state.routes[index];\n            const deeperConfig = (currentOptions[route.name] as {\n              screens: Options;\n            }).screens;\n            // if there is config for next route name, we go deeper\n            if (nextRoute.name in deeperConfig) {\n              nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n              route = nextRoute as Route<string> & { state?: State };\n              currentOptions = deeperConfig;\n            } else {\n              // if not, there is no sense in going deeper in config\n              pattern = (currentOptions[route.name] as { path: string }).path;\n              nestedRouteNames = `${nestedRouteNames}/${route.name}`;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      // cut the first `/`\n      pattern = nestedRouteNames.substring(1);\n    }\n\n    // we don't add empty path strings to path\n    if (pattern !== '') {\n      const config =\n        currentOptions[route.name] !== undefined\n          ? (currentOptions[route.name] as { stringify?: StringifyConfig })\n              .stringify\n          : undefined;\n\n      const params = route.params\n        ? // Stringify all of the param values before we use them\n          Object.entries(route.params).reduce<{\n            [key: string]: string;\n          }>((acc, [key, value]) => {\n            acc[key] = config?.[key] ? config[key](value) : String(value);\n            return acc;\n          }, {})\n        : undefined;\n\n      if (currentOptions[route.name] !== undefined) {\n        path += pattern\n          .split('/')\n          .map((p) => {\n            const name = p.replace(/^:/, '');\n\n            // If the path has a pattern for a param, put the param in the path\n            if (params && name in params && p.startsWith(':')) {\n              const value = params[name];\n              // Remove the used value from the params object since we'll use the rest for query string\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete params[name];\n              return encodeURIComponent(value);\n            }\n\n            return encodeURIComponent(p);\n          })\n          .join('/');\n      } else {\n        path += encodeURIComponent(route.name);\n      }\n\n      if (route.state) {\n        path += '/';\n      } else if (params) {\n        for (let param in params) {\n          if (params[param] === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete params[param];\n          }\n        }\n        const query = queryString.stringify(params);\n\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n    }\n\n    current = route.state;\n  }\n\n  path =\n    path !== '/' && path.slice(path.length - 1) === '/'\n      ? path.slice(0, -1)\n      : path;\n\n  return path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}