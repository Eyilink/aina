{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nexport default function getStateFromPath(path) {\n  var _ref;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (path === '') {\n    return undefined;\n  }\n  var initialRoutes = [];\n  var configs = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(options).map(function (key) {\n    return createNormalizedConfigs(key, options, [], initialRoutes);\n  })));\n  var result;\n  var current;\n  var remaining = path.replace(/[/]+/, '/').replace(/^\\//, '').replace(/\\?.*/, '');\n  while (remaining) {\n    var routeNames = void 0;\n    var params = void 0;\n    var _loop = function _loop(config) {\n      var match = remaining.match(config.match);\n      if (match) {\n        routeNames = _toConsumableArray(config.routeNames);\n        var paramPatterns = config.pattern.split('/').filter(function (p) {\n          return p.startsWith(':');\n        });\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce(function (acc, p, i) {\n            var key = p.replace(/^:/, '');\n            var value = match[i + 1];\n            acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;\n            return acc;\n          }, {});\n        }\n        remaining = remaining.replace(match[0], '');\n        return \"break\";\n      }\n    };\n    for (var _iterator = _createForOfIteratorHelperLoose(configs), _step; !(_step = _iterator()).done;) {\n      var config = _step.value;\n      var _ret = _loop(config);\n      if (_ret === \"break\") break;\n    }\n    if (routeNames === undefined) {\n      var segments = remaining.split('/');\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n    var state = void 0;\n    var routeName = routeNames.shift();\n    var initialRoute = findInitialRoute(routeName, initialRoutes);\n    state = createNestedState(initialRoute, routeName, routeNames.length === 0, params);\n    if (routeNames.length > 0) {\n      var nestedState = state;\n      while (routeName = routeNames.shift()) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(initialRoute, routeName, routeNames.length === 0, params);\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0].state;\n        }\n      }\n    }\n    if (current) {\n      var _current2;\n      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {\n        var _current;\n        current = current.routes[current.index || 0].state;\n      }\n      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;\n    } else {\n      result = state;\n    }\n    current = state;\n  }\n  if (current == null || result == null) {\n    return undefined;\n  }\n  var query = path.split('?')[1];\n  if (query) {\n    var _current4;\n    while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {\n      var _current3;\n      current = current.routes[current.index || 0].state;\n    }\n    var route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];\n    var _params = queryString.parse(query);\n    var parseFunction = findParseConfigForRoute(route.name, configs);\n    if (parseFunction) {\n      Object.keys(_params).forEach(function (name) {\n        if (parseFunction[name] && typeof _params[name] === 'string') {\n          _params[name] = parseFunction[name](_params[name]);\n        }\n      });\n    }\n    route.params = _objectSpread({}, route.params, {}, _params);\n  }\n  return result;\n}\nfunction createNormalizedConfigs(key, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 ? arguments[3] : undefined;\n  var configs = [];\n  routeNames.push(key);\n  var value = routeConfig[key];\n  if (typeof value === 'string') {\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens)\n        });\n      }\n      Object.keys(value.screens).forEach(function (nestedConfig) {\n        var result = createNormalizedConfigs(nestedConfig, value.screens, routeNames, initials);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n  routeNames.pop();\n  return configs;\n}\nfunction createConfigItem(routeNames, pattern, parse) {\n  var match = new RegExp('^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?');\n  return {\n    match: match,\n    pattern: pattern,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse\n  };\n}\nfunction findParseConfigForRoute(routeName, flatConfig) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(flatConfig), _step2; !(_step2 = _iterator2()).done;) {\n    var config = _step2.value;\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\nfunction findInitialRoute(routeName, initialRoutes) {\n  for (var _iterator3 = _createForOfIteratorHelperLoose(initialRoutes), _step3; !(_step3 = _iterator3()).done;) {\n    var config = _step3.value;\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName ? undefined : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\nfunction createNestedState(initialRoute, routeName, isEmpty, params) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    }\n  }\n}","map":{"version":3,"names":["escape","queryString","getStateFromPath","path","_ref","options","arguments","length","undefined","initialRoutes","configs","concat","apply","_toConsumableArray","Object","keys","map","key","createNormalizedConfigs","result","current","remaining","replace","routeNames","params","_loop","config","match","paramPatterns","pattern","split","filter","p","startsWith","reduce","acc","i","value","parse","_iterator","_createForOfIteratorHelperLoose","_step","done","_ret","segments","decodeURIComponent","shift","join","state","routeName","initialRoute","findInitialRoute","createNestedState","nestedState","routes","index","_current2","_current","query","_current4","_current3","route","parseFunction","findParseConfigForRoute","name","forEach","_objectSpread","routeConfig","initials","push","createConfigItem","screens","initialRouteName","connectedRoutes","nestedConfig","pop","RegExp","flatConfig","_iterator2","_step2","_iterator3","_step3","includes","isEmpty"],"sources":["C:\\Users\\HP\\Documents\\Ping\\pingaina\\node_modules\\@react-navigation\\core\\lib\\module\\getStateFromPath.tsx"],"sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  if (path === '') {\n    return undefined;\n  }\n  let initialRoutes: InitialRouteConfig[] = [];\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n    let routeName = routeNames.shift() as string;\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n    state = createNestedState(\n      initialRoute,\n      routeName,\n      routeNames.length === 0,\n      params\n    );\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while ((routeName = routeNames.shift() as string)) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\n          initialRoute,\n          routeName,\n          routeNames.length === 0,\n          params\n        );\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0]\n            .state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current?.routes[current.index || 0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = (current as PartialState<NavigationState>).routes[\n      current?.index || 0\n    ];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach((name) => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createNestedState(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}